"""React component generator for FigmaForge.

Generates React functional components with TypeScript and CSS Modules
from Figma designs, as an alternative to Angular output.
"""

from typing import Dict, Any, List, Optional
from pathlib import Path
from ..figma.types import FigmaNode
from ..utils.css import sanitize_css_class, to_camel_case, to_pascal_case


class ReactGenerator:
    """Generates React functional components from Figma designs.
    
    Produces:
    - ComponentName.tsx - React functional component with TypeScript
    - ComponentName.module.css - CSS Module styles
    """
    
    def __init__(
        self, 
        component_name: str,
        variant_inputs: Optional[List[Dict[str, Any]]] = None
    ):
        self.component_name = component_name
        self.class_name = to_pascal_case(component_name)
        self.variant_inputs = variant_inputs or []
        self.asset_paths: Dict[str, str] = {}
        self.inline_svgs: Dict[str, str] = {}
        self.jsx_elements: List[str] = []
    
    def generate_component(
        self,
        node: FigmaNode,
        asset_paths: Optional[Dict[str, str]] = None,
        inline_svgs: Optional[Dict[str, str]] = None
    ) -> Dict[str, str]:
        """Generate React component files.
        
        Returns:
            Dict with 'tsx' and 'css' keys containing file contents
        """
        self.asset_paths = asset_paths or {}
        self.inline_svgs = inline_svgs or {}
        self.jsx_elements = []
        
        # Collect JSX elements
        self._collect_jsx_elements(node)
        
        tsx_content = self._generate_tsx(node)
        css_content = self._generate_css_module(node)
        
        return {
            "tsx": tsx_content,
            "css": css_content
        }
    
    def _generate_tsx(self, node: FigmaNode) -> str:
        """Generate TypeScript React component."""
        lines = [
            "// ==================== AUTO-GEN-START ====================",
            "// Generated by FigmaForge - React Output",
            "",
            "import React from 'react';",
            f"import styles from './{self.class_name}.module.css';",
            "",
        ]
        
        # Generate props interface
        lines.append(f"export interface {self.class_name}Props {{")
        
        # Variant props
        if self.variant_inputs:
            for inp in self.variant_inputs:
                name = inp.get("name", "")
                ts_type = inp.get("type", "string")
                lines.append(f"  {name}?: {ts_type};")
        
        # Standard props
        lines.append("  className?: string;")
        lines.append("  children?: React.ReactNode;")
        lines.append("}")
        lines.append("")
        
        # Generate component
        props_destructure = ", ".join([f"{inp['name']} = '{inp['default']}'" for inp in self.variant_inputs])
        if props_destructure:
            props_destructure = f"{props_destructure}, "
        
        lines.append(f"export const {self.class_name}: React.FC<{self.class_name}Props> = ({{")
        lines.append(f"  {props_destructure}className,")
        lines.append("  children,")
        lines.append("}) => {")
        lines.append("  return (")
        lines.append(f"    <div className={{`${{styles.{self._to_css_class_name(self.component_name)}}} ${{className || ''}}`}}>")
        
        # Add collected elements
        for element in self.jsx_elements:
            lines.append(f"      {element}")
        
        lines.append("      {children}")
        lines.append("    </div>")
        lines.append("  );")
        lines.append("};")
        lines.append("")
        lines.append(f"export default {self.class_name};")
        lines.append("")
        lines.append("// ==================== AUTO-GEN-END ====================")
        
        return "\n".join(lines)
    
    def _generate_css_module(self, node: FigmaNode) -> str:
        """Generate CSS Module placeholder (actual styles come from SCSS generator)."""
        lines = [
            "/* ==================== AUTO-GEN-START ==================== */",
            "/* Generated by FigmaForge - React CSS Module */",
            "",
            f".{self._to_css_class_name(self.component_name)} {{",
            "  position: relative;",
            "  width: 100%;",
            "}",
            "",
            "/* Element styles will be generated by the SCSS generator */",
            "",
            "/* ==================== AUTO-GEN-END ==================== */",
        ]
        
        return "\n".join(lines)
    
    def _collect_jsx_elements(self, node: FigmaNode) -> None:
        """Recursively collect JSX elements from Figma node."""
        node_type = node.get("type", "")
        
        if node_type in ["DOCUMENT", "CANVAS"]:
            for child in node.get("children", []):
                if isinstance(child, dict):
                    self._collect_jsx_elements(child)
            return
        
        for child in node.get("children", []):
            if isinstance(child, dict) and child.get("visible", True):
                element = self._generate_jsx_element(child)
                if element:
                    self.jsx_elements.append(element)
                self._collect_jsx_elements(child)
    
    def _generate_jsx_element(self, node: FigmaNode) -> str:
        """Generate JSX for a single element."""
        node_type = node.get("type", "")
        class_name = self._generate_class_name(node)
        
        if node_type == "TEXT":
            return self._generate_text_jsx(node, class_name)
        elif node_type in ["RECTANGLE", "ELLIPSE", "VECTOR"]:
            node_id = node.get("id", "")
            if node_id in self.asset_paths:
                return self._generate_image_jsx(node, class_name)
        
        return self._generate_container_jsx(node, class_name)
    
    def _generate_text_jsx(self, node: FigmaNode, class_name: str) -> str:
        """Generate JSX for text element."""
        text = node.get("characters", "")
        
        if text:
            # Escape for JSX
            escaped = text.replace("{", "{{").replace("}", "}}")
            return f'<span className={{styles.{class_name}}}>{escaped}</span>'
        else:
            prop = to_camel_case(node.get("name", "text"))
            return f'<span className={{styles.{class_name}}}>{{{prop}}}</span>'
    
    def _generate_image_jsx(self, node: FigmaNode, class_name: str) -> str:
        """Generate JSX for image element."""
        node_id = node.get("id", "")
        node_name = node.get("name", "image")
        
        # Check for inline SVG
        if node_id in self.inline_svgs:
            svg_content = self.inline_svgs[node_id]
            return f'<span className={{styles.{class_name}}} dangerouslySetInnerHTML={{{{ __html: `{svg_content}` }}}} />'
        
        asset_path = self.asset_paths.get(node_id, "")
        return f'<img src="{asset_path}" alt="{node_name}" className={{styles.{class_name}}} />'
    
    def _generate_container_jsx(self, node: FigmaNode, class_name: str) -> str:
        """Generate JSX for container element."""
        return f'<div className={{styles.{class_name}}} />'
    
    def _generate_class_name(self, node: FigmaNode) -> str:
        """Generate CSS Module class name."""
        node_name = node.get("name", "element")
        node_id = node.get("id", "")
        
        # Sanitize for CSS Module usage
        class_name = self._to_css_class_name(node_name)
        
        # Handle duplicates
        duplicates = ["background", "rectangle", "group", "frame", "vector"]
        if any(d in class_name.lower() for d in duplicates):
            id_suffix = node_id.replace(":", "").replace(";", "")[-6:].lower()
            class_name = f"{class_name}_{id_suffix}"
        
        return class_name
    
    def _to_css_class_name(self, name: str) -> str:
        """Convert name to valid CSS class name for CSS Modules."""
        # Convert to camelCase for CSS Modules (works better with styles.xyz syntax)
        words = sanitize_css_class(name).replace("-", " ").split()
        if not words:
            return "element"
        
        result = words[0].lower()
        for word in words[1:]:
            result += word.capitalize()
        
        return result
