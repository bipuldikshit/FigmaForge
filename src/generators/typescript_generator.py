"""Generate Angular TypeScript component files."""

from typing import Set, Dict, Any, List, Optional
from ..figma.types import FigmaNode
from ..utils.css import to_camel_case, to_pascal_case


class TypeScriptGenerator:
    """Generates Angular standalone component TypeScript files."""
    
    def __init__(self, component_name: str, variant_inputs: Optional[List[Dict[str, Any]]] = None):
        self.component_name = component_name
        self.selector = f"app-{component_name}"
        self.class_name = to_pascal_case(component_name) + "Component"
        self.inputs: Set[str] = set()
        self.variant_inputs = variant_inputs or []  # From VariantExtractor
    
    def generate_component(self, node: FigmaNode) -> str:
        """Generate Angular component TypeScript code."""
        self._analyze_node_for_inputs(node)
        
        lines = [
            "import { Component, Input } from '@angular/core';",
            "import { CommonModule } from '@angular/common';",
            "",
            f"/** {self.class_name} - Generated by FigmaForge */",
            "@Component({",
            f"  selector: '{self.selector}',",
            "  standalone: true,",
            "  imports: [CommonModule],",
            f"  templateUrl: './{self.component_name}.component.html',",
            f"  styleUrls: ['./{self.component_name}.component.scss']",
            "})",
            f"export class {self.class_name} {{",
            "  // ==================== AUTO-GEN-START ====================",
        ]
        
        # Generate variant inputs first (with proper types)
        if self.variant_inputs:
            lines.append("  // Variant properties (from Figma Component Set)")
            for variant_input in self.variant_inputs:
                name = variant_input.get("name", "")
                ts_type = variant_input.get("type", "string")
                default = variant_input.get("default", "")
                
                # Add type alias for complex unions
                if "|" in ts_type:
                    lines.append(f"  @Input() {name}: {ts_type} = '{default}';")
                else:
                    lines.append(f"  @Input() {name}: {ts_type} = '{default}';")
        
        # Generate auto-detected inputs
        if self.inputs:
            if self.variant_inputs:
                lines.append("")
                lines.append("  // Content properties (auto-detected)")
            for input_name in sorted(self.inputs):
                input_type = self._infer_input_type(input_name)
                default_value = self._get_default_value(input_type)
                lines.append(f"  @Input() {input_name}: {input_type} = {default_value};")
        elif not self.variant_inputs:
            lines.append("  // No dynamic inputs detected")
        
        lines.extend([
            "  // ==================== AUTO-GEN-END ====================",
            "",
            "  constructor() {}",
            "}",
            ""
        ])
        
        return "\n".join(lines)
    
    def _analyze_node_for_inputs(self, node: FigmaNode) -> None:
        """Recursively analyze node to identify @Input properties."""
        node_type = node.get("type", "")
        node_name = node.get("name", "")
        
        if node_type == "TEXT":
            prop = to_camel_case(node_name or "text")
            if len(prop) > 40:
                prop = self._abbreviate(prop)
            self.inputs.add(prop)
        
        elif node_type in ["RECTANGLE", "ELLIPSE", "VECTOR"]:
            fills = node.get("fills", [])
            has_image = any(f.get("type") == "IMAGE" for f in fills)
            
            if has_image or any(k in node_name.lower() for k in ["image", "icon", "logo"]):
                prop = to_camel_case(node_name or "image")
                if not prop.lower().endswith(("url", "src")):
                    prop += "Url"
                if len(prop) > 40:
                    prop = self._abbreviate(prop)
                self.inputs.add(prop)
        
        if any(k in node_name.lower() for k in ["color", "accent", "theme"]):
            prop = to_camel_case(node_name or "color")
            if not prop.lower().endswith("color"):
                prop += "Color"
            if len(prop) > 40:
                prop = self._abbreviate(prop)
            self.inputs.add(prop)
        
        for child in node.get("children", []):
            if isinstance(child, dict):
                self._analyze_node_for_inputs(child)
    
    def _abbreviate(self, name: str) -> str:
        """Abbreviate long property names."""
        abbrevs = {
            "description": "desc", "information": "info", "message": "msg",
            "template": "tmpl", "navigation": "nav", "button": "btn",
            "image": "img", "configuration": "config", "certificate": "cert",
            "customer": "cust", "corporate": "corp", "instructions": "instr",
            "document": "doc", "application": "app"
        }
        
        words = []
        current = ""
        for c in name:
            if c.isupper() and current:
                words.append(current.lower())
                current = c
            else:
                current += c
        if current:
            words.append(current.lower())
        
        abbreviated = [abbrevs.get(w, w) for w in words]
        
        if not abbreviated:
            return name[:40]
        
        result = abbreviated[0]
        for w in abbreviated[1:]:
            result += w.capitalize()
        
        return result[:40] if len(result) > 40 else result
    
    def _infer_input_type(self, input_name: str) -> str:
        """Infer TypeScript type from input name."""
        lower = input_name.lower()
        
        if any(k in lower for k in ["url", "src", "image", "icon", "color", "theme"]):
            return "string"
        if any(k in lower for k in ["count", "number", "amount", "total"]):
            return "number"
        if lower.startswith(("is", "has", "show")) or any(k in lower for k in ["enabled", "visible", "active", "disabled"]):
            return "boolean"
        return "string"
    
    def _get_default_value(self, type_name: str) -> str:
        """Get default value for TypeScript type."""
        return {"string": "''", "number": "0", "boolean": "false", "any[]": "[]"}.get(type_name, "''")
