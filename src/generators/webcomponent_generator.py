"""Web Components (Custom Elements) generator for FigmaForge.

Generates framework-agnostic Web Components with Shadow DOM,
custom element registration, and encapsulated styles.
"""

from typing import Dict, Any, List, Optional
from pathlib import Path
from ..figma.types import FigmaNode
from ..utils.css import sanitize_css_class, to_camel_case, to_pascal_case


class WebComponentGenerator:
    """Generates Web Components (Custom Elements) from Figma designs.
    
    Produces:
    - component-name.js - Custom Element class with Shadow DOM
    - Encapsulated CSS within the component
    """
    
    def __init__(
        self, 
        component_name: str,
        variant_inputs: Optional[List[Dict[str, Any]]] = None
    ):
        self.component_name = component_name  # kebab-case for custom element
        self.class_name = to_pascal_case(component_name) + "Element"
        self.tag_name = f"app-{component_name}"  # Custom element tag
        self.variant_inputs = variant_inputs or []
        self.asset_paths: Dict[str, str] = {}
        self.inline_svgs: Dict[str, str] = {}
        self.html_elements: List[str] = []
    
    def generate_component(
        self,
        node: FigmaNode,
        asset_paths: Optional[Dict[str, str]] = None,
        inline_svgs: Optional[Dict[str, str]] = None
    ) -> Dict[str, str]:
        """Generate Web Component files.
        
        Returns:
            Dict with 'js' key containing the component class
        """
        self.asset_paths = asset_paths or {}
        self.inline_svgs = inline_svgs or {}
        self.html_elements = []
        
        # Collect HTML elements
        self._collect_html_elements(node)
        
        js_content = self._generate_web_component()
        
        return {
            "js": js_content
        }
    
    def _generate_web_component(self) -> str:
        """Generate the Web Component class."""
        observed_attrs = [f'"{inp["name"]}"' for inp in self.variant_inputs]
        observed_attrs_str = ", ".join(observed_attrs) if observed_attrs else ""
        
        # Generate property getters/setters
        property_code = self._generate_properties()
        
        # Generate template
        template = self._generate_template()
        
        # Generate styles
        styles = self._generate_styles()
        
        return f'''// ==================== AUTO-GEN-START ====================
// {self.class_name} - Generated by FigmaForge
// Usage: <{self.tag_name}></{self.tag_name}>

class {self.class_name} extends HTMLElement {{
  static get observedAttributes() {{
    return [{observed_attrs_str}];
  }}

  constructor() {{
    super();
    this.attachShadow({{ mode: 'open' }});
    this.render();
  }}

{property_code}

  connectedCallback() {{
    this.render();
  }}

  attributeChangedCallback(name, oldValue, newValue) {{
    if (oldValue !== newValue) {{
      this.render();
    }}
  }}

  render() {{
    this.shadowRoot.innerHTML = `
      <style>
{styles}
      </style>
      <div class="{self.component_name}">
{template}
        <slot></slot>
      </div>
    `;
  }}
}}

// Register the custom element
customElements.define('{self.tag_name}', {self.class_name});

export default {self.class_name};
// ==================== AUTO-GEN-END ====================
'''
    
    def _generate_properties(self) -> str:
        """Generate property getters/setters for each variant input."""
        if not self.variant_inputs:
            return "  // No properties defined"
        
        lines = []
        for inp in self.variant_inputs:
            name = inp.get("name", "")
            default = inp.get("default", "")
            
            lines.append(f'''  get {name}() {{
    return this.getAttribute('{name}') || '{default}';
  }}

  set {name}(value) {{
    this.setAttribute('{name}', value);
  }}
''')
        
        return "\n".join(lines)
    
    def _generate_template(self) -> str:
        """Generate the HTML template."""
        lines = []
        for element in self.html_elements:
            lines.append(f"        {element}")
        return "\n".join(lines)
    
    def _generate_styles(self) -> str:
        """Generate encapsulated CSS styles."""
        return f'''        :host {{
          display: block;
          position: relative;
        }}

        .{self.component_name} {{
          width: 100%;
        }}

        /* Add component-specific styles here */'''
    
    def _collect_html_elements(self, node: FigmaNode) -> None:
        """Recursively collect HTML elements."""
        node_type = node.get("type", "")
        
        if node_type in ["DOCUMENT", "CANVAS"]:
            for child in node.get("children", []):
                if isinstance(child, dict):
                    self._collect_html_elements(child)
            return
        
        for child in node.get("children", []):
            if isinstance(child, dict) and child.get("visible", True):
                element = self._generate_element(child)
                if element:
                    self.html_elements.append(element)
                self._collect_html_elements(child)
    
    def _generate_element(self, node: FigmaNode) -> str:
        """Generate HTML element."""
        node_type = node.get("type", "")
        class_name = self._generate_class_name(node)
        
        if node_type == "TEXT":
            text = node.get("characters", "")
            if text:
                escaped = text.replace("<", "&lt;").replace(">", "&gt;")
                escaped = escaped.replace("`", "\\`").replace("$", "\\$")
                return f'<span class="{class_name}">{escaped}</span>'
            return f'<span class="{class_name}"></span>'
        
        elif node_type in ["RECTANGLE", "ELLIPSE", "VECTOR"]:
            node_id = node.get("id", "")
            if node_id in self.inline_svgs:
                svg = self.inline_svgs[node_id].replace("`", "\\`").replace("$", "\\$")
                return f'<span class="{class_name}">{svg}</span>'
            elif node_id in self.asset_paths:
                path = self.asset_paths[node_id]
                return f'<img src="{path}" alt="" class="{class_name}" />'
        
        return f'<div class="{class_name}"></div>'
    
    def _generate_class_name(self, node: FigmaNode) -> str:
        """Generate CSS class name."""
        name = node.get("name", "element")
        return sanitize_css_class(name)
